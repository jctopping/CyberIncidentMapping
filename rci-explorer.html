<!DOCTYPE html>
<html>
<head>
    <title>Interactive Map of Incidents</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/Leaflet.awesome-markers/2.0.2/leaflet.awesome-markers.css">
<style>
body {
    display: flex;
    flex-direction: column;
    margin: 0;
    overflow: auto;
}

.map-frame {
    display: flex;
    justify-content: center;
    align-items: center;
    width: 100vw;
    height: 45vw;
    box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
}

.map-container {
    width: 100%;
    height: 100%;
}

#mapMain {
    width: 100%;
    height: 100%;
}

/* Style for the filter and legend boxes */
/* Style for the filter and legend boxes */
.leaflet-control.filter-box, .leaflet-control.legend-box {
    background: white;
    padding: 10px;
    border-radius: 8px;
    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
    font-family: Arial, sans-serif;
    font-size: 14px;
    line-height: 1.5;
    color: #333;
    max-height: 300px; /* Prevents overflow for longer legends */
    overflow-y: auto;  /* Adds scroll if needed */
}

.leaflet-control h4 {
    margin: 0 0 8px;
    font-size: 16px;
    color: #000;
}

.leaflet-control i {
    width: 18px;
    text-align: center;
}

.leaflet-control input[type="checkbox"] {
    margin-right: 5px;
}


</style>
</head>
<body>

<div class="map-frame">
    <div class="map-container" id="mapMain"></div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/Leaflet.awesome-markers/2.0.2/leaflet.awesome-markers.js"></script>

<script>

const API_URL = "https://n8n.coltex.net/webhook/4b940a1d-b4db-4c04-9c90-20ac201586c0";
const GEOJSON_URL = "https://raw.githubusercontent.com/jctopping/CyberIncidentMapping/main/GeoJSON/FEMA-all-regions.geojson";

// Initialize the main map
var mapMain = L.map('mapMain', { maxZoom: 19, zoomControl: true, attributionControl: true })
    .setView([37.8, -96], 5);
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(mapMain);

// Define icons for different incident types
const icons = {
    'State Government': L.AwesomeMarkers.icon({icon: 'university', prefix: 'fa', markerColor: 'red'}),
    'Local Government': L.AwesomeMarkers.icon({icon: 'city', prefix: 'fa', markerColor: 'blue'}),
    'Education': L.AwesomeMarkers.icon({icon: 'graduation-cap', prefix: 'fa', markerColor: 'green'}),
    'Tribal': L.AwesomeMarkers.icon({icon: 'globe', prefix: 'fa', markerColor: 'orange'}),
    'Critical Infrastructure': L.AwesomeMarkers.icon({icon: 'industry', prefix: 'fa', markerColor: 'darkred'}),
    'Energy': L.AwesomeMarkers.icon({icon: 'bolt', prefix: 'fa', markerColor: 'darkpurple'}),
    'Healthcare': L.AwesomeMarkers.icon({icon: 'plus-square', prefix: 'fa', markerColor: 'cadetblue'}),
    'Transportation': L.AwesomeMarkers.icon({icon: 'truck', prefix: 'fa', markerColor: 'darkgreen'}),
    'Financial': L.AwesomeMarkers.icon({icon: 'money-bill', prefix: 'fa', markerColor: 'gold'}),
    'Food / Agriculture': L.AwesomeMarkers.icon({icon: 'leaf', prefix: 'fa', markerColor: 'lightgreen'}),
    'Manufacturing / Industry': L.AwesomeMarkers.icon({icon: 'cogs', prefix: 'fa', markerColor: 'gray'}),
    'Software / IT Services': L.AwesomeMarkers.icon({icon: 'laptop', prefix: 'fa', markerColor: 'lightblue'}),
    'Commercial / Other': L.AwesomeMarkers.icon({icon: 'shopping-cart', prefix: 'fa', markerColor: 'beige'})
};

// Initialize global variables
const layerGroup = L.layerGroup().addTo(mapMain);
const regionColors = {};
let allData = []; // Store the original dataset


// Function to add incident points
function addPointsToMap(points) {
    layerGroup.clearLayers();
    points.forEach(point => {
        const markerIcon = icons[point.type] || L.AwesomeMarkers.icon({ icon: 'question', prefix: 'fa', markerColor: 'black' });

        L.marker([point.lat, point.lon], { icon: markerIcon })
            .addTo(layerGroup)
            .bindPopup(`<strong>${point.name}</strong><br>${point.city}, ${point.state}<br><b>Type:</b> ${point.type}<br><b>Category:</b> ${point.category}<br><b>Status:</b> ${point.status}<br><b>Severity:</b> ${point.severity}`);
    });
}

// Function to add FEMA region overlays
function addFemaRegionsOverlay() {
    if (window.geoJsonLayer) {
        mapMain.removeLayer(window.geoJsonLayer);
    }

    fetch(GEOJSON_URL)
        .then(response => response.json())
        .then(geoJson => {
            if (!geoJson || !geoJson.features) {
                throw new Error("Invalid GeoJSON data received.");
            }

            const uniqueColors = [
                '#ff0000', '#ff7f00', '#ffff00', '#00ff00', '#00ffff',
                '#0000ff', '#8b00ff', '#ff1493', '#ff4500', '#00fa9a'
            ];
            let colorIndex = 0;

            const impactedRegions = window.impactedRegions || new Set();

            window.geoJsonLayer = L.geoJson(geoJson, {
                style: function(feature) {
                    if (!feature.properties || feature.properties.region === undefined) {
                        console.warn("Feature has no region property:", feature);
                        return {
                            fillColor: "transparent",
                            weight: 2,
                            color: "blue",
                            fillOpacity: 0.2
                        };
                    }

                    const regionId = feature.properties.region;

                    if (impactedRegions.has(regionId)) {
                        if (!regionColors[regionId]) {
                            regionColors[regionId] = uniqueColors[colorIndex++ % uniqueColors.length];
                        }
                    }

                    return {
                        fillColor: impactedRegions.has(regionId) ? regionColors[regionId] : '#f0f0f0',
                        weight: 2,
                        opacity: 1,
                        color: 'blue',
                        fillOpacity: impactedRegions.has(regionId) ? 0.7 : 0.3
                    };
                },
                onEachFeature: function(feature, layer) {
                    layer.bindPopup(`FEMA Region: ${feature.properties.region}`);
                }
            }).addTo(mapMain);
        })
        .catch(error => console.error('Error fetching GeoJSON data:', error));
}

function updateMap() {
    layerGroup.clearLayers();  // Remove all markers

    if (window.geoJsonLayer) {
        mapMain.removeLayer(window.geoJsonLayer);  // Remove existing GeoJSON overlays
    }

    const activeStatusFilters = new Set([...document.querySelectorAll('.filter:checked')].map(el => el.dataset.filter));
    const activeTypeFilters = new Set([...document.querySelectorAll('.type-filter:checked')].map(el => el.dataset.type));
    const activeRegionFilters = new Set([...document.querySelectorAll('.region-filter:checked')].map(el => parseInt(el.dataset.region)));

    // Filter data based on selected statuses, types, and regions
    const filteredData = allData.filter(point =>
        activeStatusFilters.has(point.status) &&
        activeTypeFilters.has(point.type) &&
        activeRegionFilters.has(point.region)
    );

    // Update impacted regions based on filtered data
    window.impactedRegions = new Set(filteredData.map(point => point.region));

    // Add markers for filtered data
	filteredData.forEach(point => {
	    const markerIcon = icons[point.type] || L.AwesomeMarkers.icon({ icon: 'question', prefix: 'fa', markerColor: 'black' });

	    // Ensure date fields are treated as strings
	    const dateOccurred = point.date_occurred 
	        ? new Date(String(point.date_occurred)).toLocaleDateString('en-US') 
	        : 'Unknown';

	    const dateResolved = point.date_resolved 
	        ? new Date(String(point.date_resolved)).toLocaleDateString('en-US') 
	        : null;

	    const popupContent = `
	        <strong>${point.name}</strong><br>
	        ${point.city}, ${point.state}<br>
	        <b>Type:</b> ${point.type}<br>
	        <b>Category:</b> ${point.category}<br>
	        <b>Status:</b> ${point.status}<br>
	        <b>Severity:</b> ${point.severity}<br>
	        <b>Date Occurred:</b> ${dateOccurred}<br>
	        ${dateResolved ? `<b>Date Resolved:</b> ${dateResolved}<br>` : ''}
	    `;

	    L.marker([point.lat, point.lon], { icon: markerIcon })
	        .addTo(layerGroup)
	        .bindPopup(popupContent);
	});

    // Reapply FEMA region overlays after filtering
    addFemaRegionsOverlay();
}



// Fetch data and initialize the map
fetch(API_URL)
    .then(response => response.json())
    .then(data => {
        allData = data.map(incident => ({
            name: incident.entity || "Unknown Entity",
            type: incident.entity_type || "Unknown Type",
            city: incident.city || "Unknown City",
            state: incident.state || "Unknown State",
            lat: incident.lat ?? null,
            lon: incident.lon ?? null,
            category: (incident.incident_category && Array.isArray(incident.incident_category)) 
                      ? incident.incident_category.join(", ") 
                      : "Unknown Category",
            status: incident.incident_status || "Unknown Status",
            severity: incident.incident_severity || "Unknown Severity",
            date_occurred: incident.date_occurred || null,  // ðŸ”¥ Add date_occurred
            date_resolved: incident.date_resolved || null,  // ðŸ”¥ Add date_resolved
            region: incident.region 
                    ? parseInt(incident.region.replace(/\D/g, ""), 10)  // Normalize region to numeric format
                    : null
        }));

        window.impactedRegions = new Set(allData.map(incident => incident.region));

        updateMap(); // Show markers initially
    })
    .catch(error => console.error("Error fetching incident data:", error));


// Add event listeners to filters (only once)
document.querySelectorAll('.filter').forEach(checkbox => {
    checkbox.addEventListener('change', updateMap);
});



// Create a custom control for filters including regions
const filtersControl = L.control({ position: 'topright' });

filtersControl.onAdd = function(map) {
    const div = L.DomUtil.create('div', 'filter-box leaflet-control');
    div.innerHTML = `
        <h4>Incident Filters</h4>
        <label><input type="checkbox" class="filter" data-filter="Ongoing" checked> Ongoing Incidents</label><br>
        <label><input type="checkbox" class="filter" data-filter="Resolved"> Resolved Incidents</label> <!-- Resolved is unchecked -->
        <hr>
        <h4>FEMA Regions</h4>
        ${generateRegionFilters()} <!-- Dynamically insert region filters -->
    `;

    // Prevent map from moving when interacting with filters
    L.DomEvent.disableClickPropagation(div);

    return div;
};

// Add filter control to the map
filtersControl.addTo(mapMain);

// Function to generate region filters dynamically
function generateRegionFilters() {
    const regionNumbers = Array.from({ length: 10 }, (_, i) => i + 1);  // Regions 1 through 10
    return regionNumbers.map(region => 
        `<label><input type="checkbox" class="region-filter" data-region="${region}" checked> Region ${region}</label><br>`
    ).join('');
}

// Create a custom control for the legend with filtering
const legend = L.control({ position: 'bottomright' });

legend.onAdd = function(map) {
    const div = L.DomUtil.create('div', 'legend-box leaflet-control');
    div.innerHTML += `<h4>Legend (Click to Filter)</h4>`;

    const legendItems = [
        { label: 'State Government', color: 'red', icon: 'university' },
        { label: 'Local Government', color: 'blue', icon: 'city' },
        { label: 'Education', color: 'green', icon: 'graduation-cap' },
        { label: 'Tribal', color: 'orange', icon: 'globe' },
        { label: 'Critical Infrastructure', color: 'darkred', icon: 'industry' },
        { label: 'Energy', color: 'darkpurple', icon: 'bolt' },
        { label: 'Healthcare', color: 'cadetblue', icon: 'plus-square' },
        { label: 'Transportation', color: 'darkgreen', icon: 'truck' },
        { label: 'Financial', color: 'gold', icon: 'money-bill' },
        { label: 'Food / Agriculture', color: 'lightgreen', icon: 'leaf' },
        { label: 'Manufacturing / Industry', color: 'gray', icon: 'cogs' },
        { label: 'Software / IT Services', color: 'lightblue', icon: 'laptop' },
        { label: 'Commercial / Other', color: 'beige', icon: 'shopping-cart' }
    ];

    // Add each legend item with a clickable checkbox
    legendItems.forEach(item => {
        div.innerHTML += `
            <label class="legend-filter" data-type="${item.label}">
                <input type="checkbox" class="type-filter" data-type="${item.label}" checked>
                <i class="fa fa-${item.icon}" style="color:${item.color}; margin-right:8px;"></i> ${item.label}
            </label><br>
        `;
    });

    // Prevent the map from moving when interacting with the legend
    L.DomEvent.disableClickPropagation(div);

    return div;
};

// Add legend to the map
legend.addTo(mapMain);

// Event listeners for filters (status, type, and region)
document.addEventListener('DOMContentLoaded', () => {
    const allFilters = document.querySelectorAll('.filter, .type-filter, .region-filter');

    allFilters.forEach(checkbox => {
        checkbox.addEventListener('change', () => {
            console.log(`Filter changed: ${checkbox.dataset.filter || checkbox.dataset.type || checkbox.dataset.region}, Checked: ${checkbox.checked}`);
            updateMap();  // Update map when any filter changes
        });
    });
});

</script>

</body>
</html>